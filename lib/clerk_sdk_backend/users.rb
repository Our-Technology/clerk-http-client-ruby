# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true

require 'faraday'
require 'faraday/multipart'
require 'sorbet-runtime'

module ClerkSDKBackend
  extend T::Sig
  class Users
    extend T::Sig
    # The user object represents a user that has successfully signed up to your application.
    # https://clerk.com/docs/reference/clerkjs/user

    sig { params(sdk_config: SDKConfiguration).void }
    def initialize(sdk_config)
      @sdk_configuration = sdk_config
    end


    sig { params(request: T.nilable(::ClerkSDKBackend::Operations::GetUserListRequest)).returns(::ClerkSDKBackend::Operations::GetUserListResponse) }
    def all(request)
      # all - List all users
      # Returns a list of all users.
      # The users are returned sorted by creation date, with the newest users appearing first.
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/users"
      headers = {}
      query_params = Utils.get_query_params(::ClerkSDKBackend::Operations::GetUserListRequest, request)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.get(url) do |req|
        req.headers = headers
        req.params = query_params
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::GetUserListResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, T::Array[::ClerkSDKBackend::Shared::User])
          res.user_list = out
        end
      elsif [400, 401, 422].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(request: ::ClerkSDKBackend::Operations::CreateUserRequestBody).returns(::ClerkSDKBackend::Operations::CreateUserResponse) }
    def create(request)
      # create - Create a new user
      # Creates a new user. Your user management settings determine how you should setup your user model.
      # 
      # Any email address and phone number created using this method will be marked as verified.
      # 
      # Note: If you are performing a migration, check out our guide on [zero downtime migrations](https://clerk.com/docs/deployments/migrate-overview).
      # 
      # A rate limit rule of 20 requests per 10 seconds is applied to this endpoint.
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/users"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::CreateUserResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::User)
          res.user = out
        end
      elsif [400, 401, 403, 422].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(request: T.nilable(::ClerkSDKBackend::Operations::GetUsersCountRequest)).returns(::ClerkSDKBackend::Operations::GetUsersCountResponse) }
    def count(request)
      # count - Count users
      # Returns a total count of all users that match the given filtering criteria.
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/users/count"
      headers = {}
      query_params = Utils.get_query_params(::ClerkSDKBackend::Operations::GetUsersCountRequest, request)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.get(url) do |req|
        req.headers = headers
        req.params = query_params
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::GetUsersCountResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::TotalCount)
          res.total_count = out
        end
      elsif r.status == 422
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String).returns(::ClerkSDKBackend::Operations::GetUserResponse) }
    def find(user_id)
      # find - Retrieve a user
      # Retrieve the details of a user
      request = ::ClerkSDKBackend::Operations::GetUserRequest.new(
        
        user_id: user_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::GetUserRequest,
        base_url,
        '/users/{user_id}',
        request
      )
      headers = {}
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.get(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::GetUserResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::User)
          res.user = out
        end
      elsif [400, 401, 404].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String, request_body: ::ClerkSDKBackend::Operations::UpdateUserRequestBody).returns(::ClerkSDKBackend::Operations::UpdateUserResponse) }
    def update(user_id, request_body)
      # update - Update a user
      # Update a user's attributes.
      # 
      # You can set the user's primary contact identifiers (email address and phone numbers) by updating the `primary_email_address_id` and `primary_phone_number_id` attributes respectively.
      # Both IDs should correspond to verified identifications that belong to the user.
      # 
      # You can remove a user's username by setting the username attribute to null or the blank string "".
      # This is a destructive action; the identification will be deleted forever.
      # Usernames can be removed only if they are optional in your instance settings and there's at least one other identifier which can be used for authentication.
      # 
      # This endpoint allows changing a user's password. When passing the `password` parameter directly you have two further options.
      # You can ignore the password policy checks for your instance by setting the `skip_password_checks` parameter to `true`.
      # You can also choose to sign the user out of all their active sessions on any device once the password is updated. Just set `sign_out_of_other_sessions` to `true`.
      request = ::ClerkSDKBackend::Operations::UpdateUserRequest.new(
        
        user_id: user_id,
        request_body: request_body
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::UpdateUserRequest,
        base_url,
        '/users/{user_id}',
        request
      )
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request_body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.patch(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::UpdateUserResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::User)
          res.user = out
        end
      elsif [400, 401, 404, 422].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String).returns(::ClerkSDKBackend::Operations::DeleteUserResponse) }
    def delete(user_id)
      # delete - Delete a user
      # Delete the specified user
      request = ::ClerkSDKBackend::Operations::DeleteUserRequest.new(
        
        user_id: user_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::DeleteUserRequest,
        base_url,
        '/users/{user_id}',
        request
      )
      headers = {}
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.delete(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::DeleteUserResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::DeletedObject)
          res.deleted_object = out
        end
      elsif [400, 401, 404].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String).returns(::ClerkSDKBackend::Operations::BanUserResponse) }
    def ban(user_id)
      # ban - Ban a user
      # Marks the given user as banned, which means that all their sessions are revoked and they are not allowed to sign in again.
      request = ::ClerkSDKBackend::Operations::BanUserRequest.new(
        
        user_id: user_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::BanUserRequest,
        base_url,
        '/users/{user_id}/ban',
        request
      )
      headers = {}
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::BanUserResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::User)
          res.user = out
        end
      elsif r.status == 402
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String).returns(::ClerkSDKBackend::Operations::UnbanUserResponse) }
    def unban(user_id)
      # unban - Unban a user
      # Removes the ban mark from the given user.
      request = ::ClerkSDKBackend::Operations::UnbanUserRequest.new(
        
        user_id: user_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::UnbanUserRequest,
        base_url,
        '/users/{user_id}/unban',
        request
      )
      headers = {}
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::UnbanUserResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::User)
          res.user = out
        end
      elsif r.status == 402
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String).returns(::ClerkSDKBackend::Operations::LockUserResponse) }
    def lock(user_id)
      # lock - Lock a user
      # Marks the given user as locked, which means they are not allowed to sign in again until the lock expires.
      # Lock duration can be configured in the instance's restrictions settings.
      request = ::ClerkSDKBackend::Operations::LockUserRequest.new(
        
        user_id: user_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::LockUserRequest,
        base_url,
        '/users/{user_id}/lock',
        request
      )
      headers = {}
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::LockUserResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::User)
          res.user = out
        end
      elsif r.status == 403
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String).returns(::ClerkSDKBackend::Operations::UnlockUserResponse) }
    def unlock(user_id)
      # unlock - Unlock a user
      # Removes the lock from the given user.
      request = ::ClerkSDKBackend::Operations::UnlockUserRequest.new(
        
        user_id: user_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::UnlockUserRequest,
        base_url,
        '/users/{user_id}/unlock',
        request
      )
      headers = {}
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::UnlockUserResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::User)
          res.user = out
        end
      elsif r.status == 403
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String, request_body: ::ClerkSDKBackend::Operations::SetUserProfileImageRequestBody).returns(::ClerkSDKBackend::Operations::SetUserProfileImageResponse) }
    def set_profile_image(user_id, request_body)
      # set_profile_image - Set user profile image
      # Update a user's profile image
      request = ::ClerkSDKBackend::Operations::SetUserProfileImageRequest.new(
        
        user_id: user_id,
        request_body: request_body
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::SetUserProfileImageRequest,
        base_url,
        '/users/{user_id}/profile_image',
        request
      )
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request_body, :multipart)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::SetUserProfileImageResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::User)
          res.user = out
        end
      elsif [400, 401, 404].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String).returns(::ClerkSDKBackend::Operations::DeleteUserProfileImageResponse) }
    def delete_profile_image(user_id)
      # delete_profile_image - Delete user profile image
      # Delete a user's profile image
      request = ::ClerkSDKBackend::Operations::DeleteUserProfileImageRequest.new(
        
        user_id: user_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::DeleteUserProfileImageRequest,
        base_url,
        '/users/{user_id}/profile_image',
        request
      )
      headers = {}
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.delete(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::DeleteUserProfileImageResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::User)
          res.user = out
        end
      elsif r.status == 404
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String, request_body: ::ClerkSDKBackend::Operations::UpdateUserMetadataRequestBody).returns(::ClerkSDKBackend::Operations::UpdateUserMetadataResponse) }
    def update_metadata(user_id, request_body)
      # update_metadata - Merge and update a user's metadata
      # Update a user's metadata attributes by merging existing values with the provided parameters.
      # 
      # This endpoint behaves differently than the *Update a user* endpoint.
      # Metadata values will not be replaced entirely.
      # Instead, a deep merge will be performed.
      # Deep means that any nested JSON objects will be merged as well.
      # 
      # You can remove metadata keys at any level by setting their value to `null`.
      request = ::ClerkSDKBackend::Operations::UpdateUserMetadataRequest.new(
        
        user_id: user_id,
        request_body: request_body
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::UpdateUserMetadataRequest,
        base_url,
        '/users/{user_id}/metadata',
        request
      )
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request_body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.patch(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::UpdateUserMetadataResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::User)
          res.user = out
        end
      elsif [400, 401, 404, 422].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String, provider: ::String).returns(::ClerkSDKBackend::Operations::GetOAuthAccessTokenResponse) }
    def oauth_access_token(user_id, provider)
      # oauth_access_token - Retrieve the OAuth access token of a user
      # Fetch the corresponding OAuth access token for a user that has previously authenticated with a particular OAuth provider.
      # For OAuth 2.0, if the access token has expired and we have a corresponding refresh token, the access token will be refreshed transparently the new one will be returned.
      request = ::ClerkSDKBackend::Operations::GetOAuthAccessTokenRequest.new(
        
        user_id: user_id,
        provider: provider
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::GetOAuthAccessTokenRequest,
        base_url,
        '/users/{user_id}/oauth_access_tokens/{provider}',
        request
      )
      headers = {}
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.get(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::GetOAuthAccessTokenResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, T::Array[::ClerkSDKBackend::Operations::ResponseBody])
          res.response_bodies = out
        end
      elsif [400, 422].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String, limit: T.nilable(::Float), offset: T.nilable(::Float)).returns(::ClerkSDKBackend::Operations::UsersGetOrganizationMembershipsResponse) }
    def organization_memberships(user_id, limit = nil, offset = nil)
      # organization_memberships - Retrieve all memberships for a user
      # Retrieve a paginated list of the user's organization memberships
      request = ::ClerkSDKBackend::Operations::UsersGetOrganizationMembershipsRequest.new(
        
        user_id: user_id,
        limit: limit,
        offset: offset
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::UsersGetOrganizationMembershipsRequest,
        base_url,
        '/users/{user_id}/organization_memberships',
        request
      )
      headers = {}
      query_params = Utils.get_query_params(::ClerkSDKBackend::Operations::UsersGetOrganizationMembershipsRequest, request)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.get(url) do |req|
        req.headers = headers
        req.params = query_params
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::UsersGetOrganizationMembershipsResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::OrganizationMemberships)
          res.organization_memberships = out
        end
      elsif r.status == 403
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String, limit: T.nilable(::Float), offset: T.nilable(::Float), status: T.nilable(::ClerkSDKBackend::Operations::QueryParamStatus)).returns(::ClerkSDKBackend::Operations::UsersGetOrganizationInvitationsResponse) }
    def organization_invitations(user_id, limit = nil, offset = nil, status = nil)
      # organization_invitations - Retrieve all invitations for a user
      # Retrieve a paginated list of the user's organization invitations
      request = ::ClerkSDKBackend::Operations::UsersGetOrganizationInvitationsRequest.new(
        
        user_id: user_id,
        limit: limit,
        offset: offset,
        status: status
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::UsersGetOrganizationInvitationsRequest,
        base_url,
        '/users/{user_id}/organization_invitations',
        request
      )
      headers = {}
      query_params = Utils.get_query_params(::ClerkSDKBackend::Operations::UsersGetOrganizationInvitationsRequest, request)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.get(url) do |req|
        req.headers = headers
        req.params = query_params
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::UsersGetOrganizationInvitationsResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::OrganizationInvitationsWithPublicOrganizationData)
          res.organization_invitations_with_public_organization_data = out
        end
      elsif [400, 403, 404].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String, request_body: ::ClerkSDKBackend::Operations::VerifyPasswordRequestBody).returns(::ClerkSDKBackend::Operations::VerifyPasswordResponse) }
    def verify_password(user_id, request_body)
      # verify_password - Verify the password of a user
      # Check that the user's password matches the supplied input.
      # Useful for custom auth flows and re-verification.
      request = ::ClerkSDKBackend::Operations::VerifyPasswordRequest.new(
        
        user_id: user_id,
        request_body: request_body
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::VerifyPasswordRequest,
        base_url,
        '/users/{user_id}/verify_password',
        request
      )
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request_body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::VerifyPasswordResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Operations::VerifyPasswordResponseBody)
          res.object = out
        end
      elsif [400, 404, 422].include?(r.status)
      elsif r.status == 500
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String, request_body: ::ClerkSDKBackend::Operations::VerifyTOTPRequestBody).returns(::ClerkSDKBackend::Operations::VerifyTOTPResponse) }
    def verify_totp(user_id, request_body)
      # verify_totp - Verify a TOTP or backup code for a user
      # Verify that the provided TOTP or backup code is valid for the user.
      # Verifying a backup code will result it in being consumed (i.e. it will
      # become invalid).
      # Useful for custom auth flows and re-verification.
      request = ::ClerkSDKBackend::Operations::VerifyTOTPRequest.new(
        
        user_id: user_id,
        request_body: request_body
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::VerifyTOTPRequest,
        base_url,
        '/users/{user_id}/verify_totp',
        request
      )
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request_body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::VerifyTOTPResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Operations::VerifyTOTPResponseBody)
          res.object = out
        end
      elsif [400, 404, 422].include?(r.status)
      elsif r.status == 500
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String).returns(::ClerkSDKBackend::Operations::DisableMFAResponse) }
    def disable_mfa(user_id)
      # disable_mfa - Disable a user's MFA methods
      # Disable all of a user's MFA methods (e.g. OTP sent via SMS, TOTP on their authenticator app) at once.
      request = ::ClerkSDKBackend::Operations::DisableMFARequest.new(
        
        user_id: user_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::DisableMFARequest,
        base_url,
        '/users/{user_id}/mfa',
        request
      )
      headers = {}
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.delete(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::DisableMFAResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Operations::DisableMFAResponseBody)
          res.object = out
        end
      elsif [404, 500].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String).returns(::ClerkSDKBackend::Operations::DeleteBackupCodeResponse) }
    def delete_backup_code(user_id)
      # delete_backup_code - Disable all user's Backup codes
      # Disable all of a user's backup codes.
      request = ::ClerkSDKBackend::Operations::DeleteBackupCodeRequest.new(
        
        user_id: user_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::DeleteBackupCodeRequest,
        base_url,
        '/users/{user_id}/backup_code',
        request
      )
      headers = {}
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.delete(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::DeleteBackupCodeResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Operations::DeleteBackupCodeResponseBody)
          res.object = out
        end
      elsif [404, 500].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String, passkey_identification_id: ::String).returns(::ClerkSDKBackend::Operations::UserPasskeyDeleteResponse) }
    def delete_passkey(user_id, passkey_identification_id)
      # delete_passkey - Delete a user passkey
      # Delete the passkey identification for a given user and notify them through email.
      request = ::ClerkSDKBackend::Operations::UserPasskeyDeleteRequest.new(
        
        user_id: user_id,
        passkey_identification_id: passkey_identification_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::UserPasskeyDeleteRequest,
        base_url,
        '/users/{user_id}/passkeys/{passkey_identification_id}',
        request
      )
      headers = {}
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.delete(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::UserPasskeyDeleteResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::DeletedObject)
          res.deleted_object = out
        end
      elsif [403, 404, 500].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String, web3_wallet_identification_id: ::String).returns(::ClerkSDKBackend::Operations::UserWeb3WalletDeleteResponse) }
    def delete_web3_wallet(user_id, web3_wallet_identification_id)
      # delete_web3_wallet - Delete a user web3 wallet
      # Delete the web3 wallet identification for a given user.
      request = ::ClerkSDKBackend::Operations::UserWeb3WalletDeleteRequest.new(
        
        user_id: user_id,
        web3_wallet_identification_id: web3_wallet_identification_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::UserWeb3WalletDeleteRequest,
        base_url,
        '/users/{user_id}/web3_wallets/{web3_wallet_identification_id}',
        request
      )
      headers = {}
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.delete(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::UserWeb3WalletDeleteResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::DeletedObject)
          res.deleted_object = out
        end
      elsif [400, 403, 404, 500].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String).returns(::ClerkSDKBackend::Operations::CreateUserTOTPResponse) }
    def create_totp(user_id)
      # create_totp - Create a TOTP for a user
      # Creates a TOTP (Time-based One-Time Password) for a given user, returning both the TOTP secret and the URI.
      # 
      request = ::ClerkSDKBackend::Operations::CreateUserTOTPRequest.new(
        
        user_id: user_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::CreateUserTOTPRequest,
        base_url,
        '/users/{user_id}/totp',
        request
      )
      headers = {}
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::CreateUserTOTPResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, T::Hash[Symbol, ::Object])
          res.totp = out
        end
      elsif [403, 404, 500].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String).returns(::ClerkSDKBackend::Operations::DeleteTOTPResponse) }
    def delete_totp(user_id)
      # delete_totp - Delete all the user's TOTPs
      # Deletes all of the user's TOTPs.
      request = ::ClerkSDKBackend::Operations::DeleteTOTPRequest.new(
        
        user_id: user_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::DeleteTOTPRequest,
        base_url,
        '/users/{user_id}/totp',
        request
      )
      headers = {}
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.delete(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::DeleteTOTPResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Operations::DeleteTOTPResponseBody)
          res.object = out
        end
      elsif [404, 500].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end


    sig { params(user_id: ::String, external_account_id: ::String).returns(::ClerkSDKBackend::Operations::DeleteExternalAccountResponse) }
    def delete_external_account(user_id, external_account_id)
      # delete_external_account - Delete External Account
      # Delete an external account by ID.
      request = ::ClerkSDKBackend::Operations::DeleteExternalAccountRequest.new(
        
        user_id: user_id,
        external_account_id: external_account_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        ::ClerkSDKBackend::Operations::DeleteExternalAccountRequest,
        base_url,
        '/users/{user_id}/external_accounts/{external_account_id}',
        request
      )
      headers = {}
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      r = @sdk_configuration.client.delete(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk_configuration.security) if !@sdk_configuration.nil? && !@sdk_configuration.security.nil?
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = ::ClerkSDKBackend::Operations::DeleteExternalAccountResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::DeletedObject)
          res.deleted_object = out
        end
      elsif [400, 403, 404, 500].include?(r.status)
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, ::ClerkSDKBackend::Shared::ClerkErrors)
          res.clerk_errors = out
        end
      end
      res
    end
  end
end
